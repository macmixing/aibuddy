import subprocess
import logging
import os
import time
import sys
import traceback
import re
import json
import sqlite3
import openai
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple

# Import configuration
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from database.message_db import get_latest_imessages, group_related_messages, resolve_attachment_path, get_db_connection
from config import PICTURES_DIR, OPENAI_API_KEY, ASSISTANT_ID, POLLING_INTERVAL
from utils.file_handling import cleanup_temp_files, get_file_type, download_attachment_to_directory
from ai.document_analysis import extract_text_from_file, analyze_document_with_ai
from ai.image_analysis import transcribe_audio, is_image_request
from ai.assistant import get_ai_assistant_response, get_ai_assistant_image_response
from ai.image_generation import generate_image
from web.search import is_web_search_request, search_web, summarize_search_results, LAST_SEARCH, update_conversation_context, CONVERSATION_CONTEXT

# Set polling interval (in seconds)
DEFAULT_POLLING_INTERVAL = 1.0
# Set a minimum interval between message processing to avoid overloading
MIN_PROCESSING_INTERVAL = 0.1

# Track the last time we processed messages
last_processing_time = 0

# Dictionary to track recently processed message groups to avoid duplicates
RECENTLY_PROCESSED_GROUPS = {}

# Set OpenAI API key
openai.api_key = OPENAI_API_KEY

def send_message(recipient, message, service):
    """
    Send message via AppleScript
    
    Args:
        recipient (str): Phone number or email
        message (str): Message text
        service (str): Service type (iMessage or SMS)
        
    Returns:
        bool: Success status
    """
    logging.info(f"üì§ Sending message to {recipient} via {service}: {message}")

    service_type = "iMessage" if service and service.lower() == "imessage" else "SMS"
    
    # Escape double quotes in the message
    message = message.replace('"', '\\"')

    script = f'''
    tell application "Messages"
        set targetService to first service whose service type is {service_type}
        set targetBuddy to buddy "{recipient}" of targetService
        send "{message}" to targetBuddy
    end tell
    '''

    result = subprocess.run(["osascript", "-e", script], capture_output=True, text=True)
    
    if result.returncode != 0:
        logging.error(f"‚ùå AppleScript Error: {result.stderr}")
        return False
    return True

def send_image(recipient, image_path, service):
    """
    Send image via AppleScript
    
    Args:
        recipient (str): Recipient phone number or email
        image_path (str): Path to image file
        service (str): Service type (iMessage or SMS)
        
    Returns:
        bool: True if successful, False otherwise
    """
    start_time = time.time()
    logging.info(f"üì§ Sending image to {recipient} via {service}: {image_path}")
    
    # Check if file exists
    if not os.path.exists(image_path):
        logging.error(f"‚ùå Image file not found: {image_path}")
        return False
    
    # Normalize service name to handle different formats
    service_lower = service.lower() if service else ""
    
    # Determine the correct service type for AppleScript
    if service_lower == "imessage" or service_lower == "ichat":
        service_type = "iMessage"
    else:
        # Default to SMS for any other service or if service is None
        service_type = "SMS"
    
    logging.info(f"üîÑ Using service type: {service_type} (original: {service})")
    
    # Escape paths with spaces
    image_path = image_path.replace(" ", "\\ ")
    
    script = f'''
    tell application "Messages"
        set targetService to first service whose service type is {service_type}
        set targetBuddy to buddy "{recipient}" of targetService
        send POSIX file "{image_path}" to targetBuddy
    end tell
    '''

    result = subprocess.run(["osascript", "-e", script], capture_output=True, text=True)
    
    end_time = time.time()
    if result.returncode != 0:
        logging.error(f"‚ùå AppleScript Error (Image Message): {result.stderr}")
        return False
    
    logging.info(f"üì§ Image sent in {end_time - start_time:.2f} seconds")
    return True

def generate_and_send_image(recipient, prompt_text, service):
    """
    Generate an image using DALL-E and send it
    
    Args:
        recipient (str): Recipient phone number or email
        prompt_text (str): Image generation prompt
        service (str): Service type (iMessage or SMS)
        
    Returns:
        bool: True if successful, False otherwise
    """
    start_time = time.time()
    
    try:
        # Clean up the prompt by removing image generation keywords
        original_prompt = prompt_text
        
        # First, remove any leading non-alphabetic characters
        prompt_text = re.sub(r'^[^a-zA-Z]+', '', prompt_text)
        
        # If the first character is a single letter followed by a capital letter, remove the first letter
        # This handles cases like "FCreate" or "HGenerate"
        prompt_text = re.sub(r'^[a-zA-Z](?=[A-Z])', '', prompt_text)
        
        # Patterns to remove from the prompt
        cleanup_patterns = [
            r"(?i)^(generate|create|make|draw|show me|imagine)(\s+a|\s+an)?\s+(image|picture|photo|drawing|illustration|artwork|graphic)(\s+of)?\s+",
            r"(?i)^(generate|create|make|draw|show me|imagine)(\s+a|\s+an)?\s+",
            r"(?i)^(image|picture|photo|drawing|illustration|artwork|graphic)\s+of\s+",
            r"(?i)^(can you|could you|please)(\s+generate|\s+create|\s+make|\s+draw|\s+show me)(\s+a|\s+an)?(\s+image|\s+picture|\s+photo|\s+drawing|\s+illustration|\s+artwork|\s+graphic)?(\s+of)?\s+",
            r"(?i)^(dall-e|dalle|ai)(\s+generate|\s+create|\s+make|\s+draw)(\s+a|\s+an)?(\s+image|\s+picture|\s+photo|\s+drawing|\s+illustration|\s+artwork|\s+graphic)?(\s+of)?\s+"
        ]
        
        # Apply each pattern to clean up the prompt
        for pattern in cleanup_patterns:
            cleaned = re.sub(pattern, "", prompt_text)
            # Only apply the substitution if it actually changed something
            if cleaned != prompt_text:
                prompt_text = cleaned
                break
        
        # Capitalize the first letter if needed
        if prompt_text and len(prompt_text) > 0:
            prompt_text = prompt_text[0].upper() + prompt_text[1:]
        
        # Log the original and cleaned prompts
        logging.info(f"üé® Original prompt: {original_prompt}")
        logging.info(f"üé® Cleaned prompt for DALL-E: {prompt_text}")
        
        # Generate the image using our generate_image function
        image_path = generate_image(prompt_text)
        
        if not image_path:
            logging.error("‚ùå Failed to generate image")
            send_message(recipient, "I'm sorry, I encountered an error generating the image.", service)
            return False
        
        # Send the image
        logging.info(f"üé® Sending generated image to recipient")
        send_success = send_image(recipient, image_path, service)
        
        end_time = time.time()
        logging.info(f"üé® Total image generation and sending time: {end_time - start_time:.2f} seconds")
        
        return send_success
        
    except Exception as e:
        logging.error(f"‚ùå Error generating image: {e}")
        logging.error(traceback.format_exc())
        send_message(recipient, f"I'm sorry, I encountered an error generating the image: {str(e)}", service)
        return False

def process_message_group(message_group):
    """
    Process a group of related messages
    
    Args:
        message_group (list): List of related message tuples
        
    Returns:
        bool: True if processing was successful, False otherwise
    """
    if not message_group:
        return False
        
    # Create a unique identifier for this message group to avoid duplicate processing
    group_id = f"{message_group[0][1]}_{message_group[0][5]}"
    
    # Check if we've recently processed this group
    current_time = time.time()
    if group_id in RECENTLY_PROCESSED_GROUPS:
        last_processed_time = RECENTLY_PROCESSED_GROUPS[group_id]
        if current_time - last_processed_time < 60:  # Within the last minute
            logging.warning(f"‚ö†Ô∏è Skipping duplicate message group from {message_group[0][1]} (processed {current_time - last_processed_time:.1f}s ago)")
            return False
    
    # Update the recently processed groups
    RECENTLY_PROCESSED_GROUPS[group_id] = current_time
    
    # Clean up old entries from the recently processed groups
    for old_group_id in list(RECENTLY_PROCESSED_GROUPS.keys()):
        if current_time - RECENTLY_PROCESSED_GROUPS[old_group_id] > 300:  # Older than 5 minutes
            del RECENTLY_PROCESSED_GROUPS[old_group_id]
    
    # Log the message group
    sender = message_group[0][1]
    logging.info(f"üì© Processing message group from {sender} with {len(message_group)} messages")
    
    # Debug log: print details for each message in the group
    for msg in message_group:
        rowid, sender, text, filename, service, date, mime_type, message_id, chat_guid, date2 = msg
        logging.debug(f"  Message: ROWID={rowid}, sender={sender}, text={text}, file={filename}, service={service}")
    
    # Check if any message in the group has text
    has_text = any(msg[2] for msg in message_group)
    
    # Check if any message in the group has an attachment
    has_attachment = any(msg[3] for msg in message_group)
        
    # Combine text from all messages in the group
    combined_text = " ".join([msg[2] for msg in message_group if msg[2]])
        
    # Process attachments if any
    if has_attachment:
        for msg in message_group:
            rowid, sender, text, filename, service, date, mime_type, message_id, chat_guid, date2 = msg
            
            if filename:
                # Use the combined text from all messages in the group as context
                attachment_text = combined_text
                
                # If there's no combined text, we'll use an empty string
                if not attachment_text:
                    attachment_text = ""
                    logging.info(f"üìé Processing attachment without text context: {filename}")
                else:
                    logging.info(f"üìé Processing attachment with text context: {filename}")
                    logging.info(f"üìù Text context: {attachment_text}")
                
                # Process the attachment
                process_attachment(sender, filename, mime_type, attachment_text, chat_guid)
    
    # Process text if any and no attachment
    elif has_text:
        logging.info(f"üí¨ Processing text message: {combined_text}")
        
        # Check if this is an image generation request
        if is_image_request(combined_text):
            logging.info(f"üé® Image generation request detected: {combined_text}")
            
            # Generate and send image
            service = message_group[0][4]  # Get the service from the first message
            generate_and_send_image(sender, combined_text, service)
            return True
        
        # Check if this is a web search request
        elif is_web_search_request(combined_text, chat_guid):
            logging.info(f"üîç Detected web search request: {combined_text}")
            
            # Perform web search
            search_results = search_web(combined_text, chat_guid=chat_guid)
            
            # Summarize search results
            summary = summarize_search_results(combined_text, search_results, chat_guid=chat_guid)
            
            # Send the summary as a response
            send_imessage(sender, summary)
            
            # Update conversation context with the search results
            update_conversation_context(chat_guid, combined_text)
            update_conversation_context(chat_guid, summary)
            
            # Ensure the search query and results are added to the Assistant thread
            try:
                from ai.assistant import conversation_threads, check_and_wait_for_active_runs
                
                if chat_guid and chat_guid in conversation_threads:
                    thread_id = conversation_threads[chat_guid]
                    
                    # Check for active runs and wait for them to complete
                    if check_and_wait_for_active_runs(thread_id):
                        # Add the user's search query to the thread
                        openai.beta.threads.messages.create(
                            thread_id=thread_id,
                            role="user",
                            content=combined_text
                        )
                        
                        # Add the search results as an assistant message to maintain context
                        openai.beta.threads.messages.create(
                            thread_id=thread_id,
                            role="assistant",
                            content=summary
                        )
                        logging.info(f"‚úÖ Added web search query and results to Assistant thread for context continuity")
                    else:
                        logging.warning("‚ö†Ô∏è Could not add web search results to thread due to active runs")
            except Exception as e:
                logging.error(f"‚ùå Error adding web search results to Assistant thread: {e}")
            
            return True
        
        # Get AI assistant response
        response = get_ai_assistant_response(chat_guid, combined_text)
        
        # Send the response
        if response:
            send_imessage(sender, response)
            return True
    
    return True

def monitor_messages(polling_interval=POLLING_INTERVAL):
    """
    Monitor for new messages and process them
    
    Args:
        polling_interval (int): Polling interval in seconds
        
    Returns:
        None
    """
    global last_processing_time
    
    logging.info(f"üëÄ Starting message monitoring with polling interval of {polling_interval} seconds...")
    
    try:
        while True:
            # Get new messages
            new_messages = get_latest_imessages()
            
            if new_messages:
                logging.info(f"üì• Received {len(new_messages)} new messages")
                
                # Group related messages
                message_groups = group_related_messages(new_messages)
                
                # Process each group
                for group in message_groups:
                    process_message_group(group)
                    # Small delay between processing groups to avoid race conditions
                    time.sleep(0.1)
            
            # Sleep for the polling interval
            time.sleep(polling_interval)
            
    except KeyboardInterrupt:
        logging.info("üëã Message monitoring stopped by user")
    except Exception as e:
        logging.error(f"‚ùå Error in message monitoring: {e}")
        logging.error(traceback.format_exc())
        raise 

def process_attachment(sender, filename, mime_type, text_context, chat_guid):
    """
    Process an attachment with optional text context
    
    Args:
        sender (str): The sender's phone number or email
        filename (str): The filename of the attachment
        mime_type (str): The MIME type of the attachment
        text_context (str): Optional text context for the attachment
        chat_guid (str): The chat GUID
        
    Returns:
        bool: True if processing was successful, False otherwise
    """
    try:
        # Resolve the attachment path
        file_path = resolve_attachment_path(filename)
        
        if not file_path:
            logging.error(f"‚ùå Could not resolve attachment path: {filename}")
            send_imessage(sender, "I received a file but couldn't access it. Please try sending it again.")
            return False
        
        # Determine file type - check both extension and mime_type
        file_type = get_file_type(file_path)
        
        # Copy the file to our pictures directory
        local_path = download_attachment_to_directory(file_path, file_type)
        
        # Process based on file type
        if file_type == "image":
            # Analyze image
            logging.info(f"üñºÔ∏è Analyzing image: {os.path.basename(local_path)}")
            
            # Log if there's text with the image
            if text_context:
                logging.info(f"üìù Processing image with text context: '{text_context}'")
            
            # Get response from AI using Assistant API for better context maintenance
            response = get_ai_assistant_image_response(chat_guid, local_path, text_context)
            
            # Update conversation context with the response directly (no prefix)
            update_conversation_context(chat_guid, response)
            
            # If there's text with the image, also update context with that
            if text_context:
                update_conversation_context(chat_guid, text_context)
            
            # Send the response
            if response:
                send_imessage(sender, response)
                return True
            else:
                send_imessage(sender, "I couldn't analyze that image. Please try again with a clearer image.")
                return False
        elif file_type == "document":
            # Extract text from document
            logging.info(f"üìÑ Extracting text from document: {os.path.basename(local_path)}")
            text_content = extract_text_from_file(local_path)
            
            # Analyze document
            response = analyze_document_with_ai(chat_guid, local_path, text_content, text_context)
            
            # Update conversation context with the document analysis
            update_conversation_context(chat_guid, f"Document analysis: {response}")
            
            # If there's text with the document, also update context with that
            if text_context:
                update_conversation_context(chat_guid, text_context)
            
            if chat_guid not in LAST_SEARCH:
                LAST_SEARCH[chat_guid] = {}
            
            # Store the document context and response
            LAST_SEARCH[chat_guid]['original_query'] = f"Document analysis of {os.path.basename(local_path)}"
            LAST_SEARCH[chat_guid]['last_response'] = response
            
            # Send the response
            send_imessage(sender, response)
            
            # Clean up temporary files
            cleanup_temp_files()
            logging.info("üßπ Cleaned up temporary document files")
        elif file_type == "audio":
            # Convert audio to text
            logging.info(f"üéµ Transcribing audio: {os.path.basename(local_path)}")
            transcription = transcribe_audio(local_path)
            
            # Get response to transcription from AI assistant
            response = get_ai_assistant_response(chat_guid, f"Transcription: {transcription}\n\nUser message: {text_context}")
            
            # Send the response
            send_imessage(sender, response)
        else:
            # Handle unsupported file types
            logging.warning(f"‚ö†Ô∏è Unsupported file type: {file_type}")
            response = f"I received a file of type {file_type}, but I'm not sure how to process it."
            send_imessage(sender, response)
        
        return True
        
    except Exception as e:
        logging.error(f"‚ùå Error processing attachment: {e}")
        traceback.print_exc()
        try:
            send_imessage(sender, f"I'm sorry, I encountered an error processing your attachment: {str(e)}")
        except Exception as send_error:
            logging.error(f"‚ùå Failed to send error message: {send_error}")
        return False 
    finally:
        # Always clean up temporary files
        cleanup_temp_files()
        logging.info("üßπ Cleaned up temporary files after attachment processing")

def send_imessage(recipient, message):
    """
    Send an iMessage to the specified recipient
    
    Args:
        recipient (str): The recipient's phone number or email
        message (str): The message to send
        
    Returns:
        bool: True if the message was sent successfully, False otherwise
    """
    try:
        # Escape double quotes in the message
        escaped_message = message.replace('"', '\\"')
        
        # Create the AppleScript command
        applescript = f'''
        tell application "Messages"
            send "{escaped_message}" to buddy "{recipient}"
        end tell
        '''
        
        # Execute the AppleScript command
        process = subprocess.run(["osascript", "-e", applescript], capture_output=True, text=True)
        
        if process.returncode != 0:
            logging.error(f"‚ùå Error sending iMessage: {process.stderr}")
            return False
        else:
            logging.info(f"‚úÖ iMessage sent to {recipient}")
            return True
    except Exception as e:
        logging.error(f"‚ùå Error sending iMessage: {e}")
        traceback.print_exc()
        return False 